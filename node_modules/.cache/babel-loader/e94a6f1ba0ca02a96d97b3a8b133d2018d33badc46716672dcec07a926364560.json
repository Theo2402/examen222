{"ast":null,"code":"import utils from'./../utils.js';import settle from'./../core/settle.js';import transitionalDefaults from'../defaults/transitional.js';import AxiosError from'../core/AxiosError.js';import CanceledError from'../cancel/CanceledError.js';import parseProtocol from'../helpers/parseProtocol.js';import platform from'../platform/index.js';import AxiosHeaders from'../core/AxiosHeaders.js';import progressEventReducer from'../helpers/progressEventReducer.js';import resolveConfig from\"../helpers/resolveConfig.js\";const isXHRAdapterSupported=typeof XMLHttpRequest!=='undefined';export default isXHRAdapterSupported&&function(config){return new Promise(function dispatchXhrRequest(resolve,reject){const _config=resolveConfig(config);let requestData=_config.data;const requestHeaders=AxiosHeaders.from(_config.headers).normalize();let{responseType}=_config;let onCanceled;function done(){if(_config.cancelToken){_config.cancelToken.unsubscribe(onCanceled);}if(_config.signal){_config.signal.removeEventListener('abort',onCanceled);}}let request=new XMLHttpRequest();request.open(_config.method.toUpperCase(),_config.url,true);// Set the request timeout in MS\nrequest.timeout=_config.timeout;function onloadend(){if(!request){return;}// Prepare the response\nconst responseHeaders=AxiosHeaders.from('getAllResponseHeaders'in request&&request.getAllResponseHeaders());const responseData=!responseType||responseType==='text'||responseType==='json'?request.responseText:request.response;const response={data:responseData,status:request.status,statusText:request.statusText,headers:responseHeaders,config,request};settle(function _resolve(value){resolve(value);done();},function _reject(err){reject(err);done();},response);// Clean up request\nrequest=null;}if('onloadend'in request){// Use onloadend if available\nrequest.onloadend=onloadend;}else{// Listen for ready state to emulate onloadend\nrequest.onreadystatechange=function handleLoad(){if(!request||request.readyState!==4){return;}// The request errored out and we didn't get a response, this will be\n// handled by onerror instead\n// With one exception: request that using file: protocol, most browsers\n// will return status as 0 even though it's a successful request\nif(request.status===0&&!(request.responseURL&&request.responseURL.indexOf('file:')===0)){return;}// readystate handler is calling before onerror or ontimeout handlers,\n// so we should call onloadend on the next 'tick'\nsetTimeout(onloadend);};}// Handle browser request cancellation (as opposed to a manual cancellation)\nrequest.onabort=function handleAbort(){if(!request){return;}reject(new AxiosError('Request aborted',AxiosError.ECONNABORTED,_config,request));// Clean up request\nrequest=null;};// Handle low level network errors\nrequest.onerror=function handleError(){// Real errors are hidden from us by the browser\n// onerror should only fire if it's a network error\nreject(new AxiosError('Network Error',AxiosError.ERR_NETWORK,_config,request));// Clean up request\nrequest=null;};// Handle timeout\nrequest.ontimeout=function handleTimeout(){let timeoutErrorMessage=_config.timeout?'timeout of '+_config.timeout+'ms exceeded':'timeout exceeded';const transitional=_config.transitional||transitionalDefaults;if(_config.timeoutErrorMessage){timeoutErrorMessage=_config.timeoutErrorMessage;}reject(new AxiosError(timeoutErrorMessage,transitional.clarifyTimeoutError?AxiosError.ETIMEDOUT:AxiosError.ECONNABORTED,_config,request));// Clean up request\nrequest=null;};// Remove Content-Type if data is undefined\nrequestData===undefined&&requestHeaders.setContentType(null);// Add headers to the request\nif('setRequestHeader'in request){utils.forEach(requestHeaders.toJSON(),function setRequestHeader(val,key){request.setRequestHeader(key,val);});}// Add withCredentials to request if needed\nif(!utils.isUndefined(_config.withCredentials)){request.withCredentials=!!_config.withCredentials;}// Add responseType to request if needed\nif(responseType&&responseType!=='json'){request.responseType=_config.responseType;}// Handle progress if needed\nif(typeof _config.onDownloadProgress==='function'){request.addEventListener('progress',progressEventReducer(_config.onDownloadProgress,true));}// Not all browsers support upload events\nif(typeof _config.onUploadProgress==='function'&&request.upload){request.upload.addEventListener('progress',progressEventReducer(_config.onUploadProgress));}if(_config.cancelToken||_config.signal){// Handle cancellation\n// eslint-disable-next-line func-names\nonCanceled=cancel=>{if(!request){return;}reject(!cancel||cancel.type?new CanceledError(null,config,request):cancel);request.abort();request=null;};_config.cancelToken&&_config.cancelToken.subscribe(onCanceled);if(_config.signal){_config.signal.aborted?onCanceled():_config.signal.addEventListener('abort',onCanceled);}}const protocol=parseProtocol(_config.url);if(protocol&&platform.protocols.indexOf(protocol)===-1){reject(new AxiosError('Unsupported protocol '+protocol+':',AxiosError.ERR_BAD_REQUEST,config));return;}// Send the request\nrequest.send(requestData||null);});};","map":{"version":3,"names":["utils","settle","transitionalDefaults","AxiosError","CanceledError","parseProtocol","platform","AxiosHeaders","progressEventReducer","resolveConfig","isXHRAdapterSupported","XMLHttpRequest","config","Promise","dispatchXhrRequest","resolve","reject","_config","requestData","data","requestHeaders","from","headers","normalize","responseType","onCanceled","done","cancelToken","unsubscribe","signal","removeEventListener","request","open","method","toUpperCase","url","timeout","onloadend","responseHeaders","getAllResponseHeaders","responseData","responseText","response","status","statusText","_resolve","value","_reject","err","onreadystatechange","handleLoad","readyState","responseURL","indexOf","setTimeout","onabort","handleAbort","ECONNABORTED","onerror","handleError","ERR_NETWORK","ontimeout","handleTimeout","timeoutErrorMessage","transitional","clarifyTimeoutError","ETIMEDOUT","undefined","setContentType","forEach","toJSON","setRequestHeader","val","key","isUndefined","withCredentials","onDownloadProgress","addEventListener","onUploadProgress","upload","cancel","type","abort","subscribe","aborted","protocol","protocols","ERR_BAD_REQUEST","send"],"sources":["/Users/theodiloreto/Desktop/examen 5 3/jo/src/node_modules/axios/lib/adapters/xhr.js"],"sourcesContent":["import utils from './../utils.js';\nimport settle from './../core/settle.js';\nimport transitionalDefaults from '../defaults/transitional.js';\nimport AxiosError from '../core/AxiosError.js';\nimport CanceledError from '../cancel/CanceledError.js';\nimport parseProtocol from '../helpers/parseProtocol.js';\nimport platform from '../platform/index.js';\nimport AxiosHeaders from '../core/AxiosHeaders.js';\nimport progressEventReducer from '../helpers/progressEventReducer.js';\nimport resolveConfig from \"../helpers/resolveConfig.js\";\n\nconst isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';\n\nexport default isXHRAdapterSupported && function (config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    const _config = resolveConfig(config);\n    let requestData = _config.data;\n    const requestHeaders = AxiosHeaders.from(_config.headers).normalize();\n    let {responseType} = _config;\n    let onCanceled;\n    function done() {\n      if (_config.cancelToken) {\n        _config.cancelToken.unsubscribe(onCanceled);\n      }\n\n      if (_config.signal) {\n        _config.signal.removeEventListener('abort', onCanceled);\n      }\n    }\n\n    let request = new XMLHttpRequest();\n\n    request.open(_config.method.toUpperCase(), _config.url, true);\n\n    // Set the request timeout in MS\n    request.timeout = _config.timeout;\n\n    function onloadend() {\n      if (!request) {\n        return;\n      }\n      // Prepare the response\n      const responseHeaders = AxiosHeaders.from(\n        'getAllResponseHeaders' in request && request.getAllResponseHeaders()\n      );\n      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?\n        request.responseText : request.response;\n      const response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config,\n        request\n      };\n\n      settle(function _resolve(value) {\n        resolve(value);\n        done();\n      }, function _reject(err) {\n        reject(err);\n        done();\n      }, response);\n\n      // Clean up request\n      request = null;\n    }\n\n    if ('onloadend' in request) {\n      // Use onloadend if available\n      request.onloadend = onloadend;\n    } else {\n      // Listen for ready state to emulate onloadend\n      request.onreadystatechange = function handleLoad() {\n        if (!request || request.readyState !== 4) {\n          return;\n        }\n\n        // The request errored out and we didn't get a response, this will be\n        // handled by onerror instead\n        // With one exception: request that using file: protocol, most browsers\n        // will return status as 0 even though it's a successful request\n        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n          return;\n        }\n        // readystate handler is calling before onerror or ontimeout handlers,\n        // so we should call onloadend on the next 'tick'\n        setTimeout(onloadend);\n      };\n    }\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, _config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, _config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      let timeoutErrorMessage = _config.timeout ? 'timeout of ' + _config.timeout + 'ms exceeded' : 'timeout exceeded';\n      const transitional = _config.transitional || transitionalDefaults;\n      if (_config.timeoutErrorMessage) {\n        timeoutErrorMessage = _config.timeoutErrorMessage;\n      }\n      reject(new AxiosError(\n        timeoutErrorMessage,\n        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,\n        _config,\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Remove Content-Type if data is undefined\n    requestData === undefined && requestHeaders.setContentType(null);\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {\n        request.setRequestHeader(key, val);\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(_config.withCredentials)) {\n      request.withCredentials = !!_config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (responseType && responseType !== 'json') {\n      request.responseType = _config.responseType;\n    }\n\n    // Handle progress if needed\n    if (typeof _config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', progressEventReducer(_config.onDownloadProgress, true));\n    }\n\n    // Not all browsers support upload events\n    if (typeof _config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', progressEventReducer(_config.onUploadProgress));\n    }\n\n    if (_config.cancelToken || _config.signal) {\n      // Handle cancellation\n      // eslint-disable-next-line func-names\n      onCanceled = cancel => {\n        if (!request) {\n          return;\n        }\n        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);\n        request.abort();\n        request = null;\n      };\n\n      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);\n      if (_config.signal) {\n        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener('abort', onCanceled);\n      }\n    }\n\n    const protocol = parseProtocol(_config.url);\n\n    if (protocol && platform.protocols.indexOf(protocol) === -1) {\n      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));\n      return;\n    }\n\n\n    // Send the request\n    request.send(requestData || null);\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}